using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace Cysharp.AI;

[Generator(LanguageNames.CSharp)]
public class ToonEncoderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(EmitAttributes);

        var tabularArray = context.SyntaxProvider.ForAttributeWithMetadataName("Cysharp.AI.GenerateToonTabularArrayConverter",
            (node, cancellationToken) => true,
            (context, cancellationToken) =>
            {
                if (context.TargetSymbol is ITypeSymbol typeSymbol)
                {
                    return new ToonObjectInfo(typeSymbol);
                }
                else
                {
                    return null;
                }
            })
            .Where(x => x != null);

        context.RegisterSourceOutput(tabularArray, EmitTabularArrayConverter!);

        var simpleObject = context.SyntaxProvider.ForAttributeWithMetadataName("Cysharp.AI.GenerateToonSimpleObjectConverter",
            (node, cancellationToken) => true,
            (context, cancellationToken) =>
            {
                if (context.TargetSymbol is ITypeSymbol typeSymbol)
                {
                    return new ToonObjectInfo(typeSymbol);
                }
                else
                {
                    return null;
                }
            })
            .Where(x => x != null);

        context.RegisterSourceOutput(simpleObject, EmitSimpleObjectConverter!);
    }

    static void EmitAttributes(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource("GenerateToonTabularArrayConverter.g.cs", """
// <auto-generated/>
#pragma warning disable
#nullable enable

using System;

namespace Cysharp.AI
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    internal sealed class GenerateToonTabularArrayConverter : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    internal sealed class GenerateToonSimpleObjectConverter : Attribute
    {
    }
}
""".ReplaceLineEndings());
    }

    static void EmitTabularArrayConverter(SourceProductionContext sourceProductionContext, ToonObjectInfo objectInfo)
    {
        if (!objectInfo.VerifyTabularArray(sourceProductionContext))
        {
            return;
        }

        var converterName = $"{objectInfo.ElementFullName.Replace("global::", "").Replace(".", "_")}TabularArrayConverter";
        var arrayType = $"{objectInfo.ElementFullName}[]?";
        var utf8FieldNames = string.Join(", ", objectInfo.PropertyNames.Select(n => $"\"{n}\"u8.ToArray()"));
        var encodeRow = string.Join("\n", objectInfo.PropertyNames.Select((name, index) =>
        {
            var kind = objectInfo.PropertyKinds![index];
            var str = kind switch
            {
                ToonPrimitiveKind.Boolean => $"toonWriter.WriteBoolean(item.{name});",
                ToonPrimitiveKind.String => $"toonWriter.WriteString(item.{name});",
                ToonPrimitiveKind.Number => $"toonWriter.WriteNumber(item.{name});",
                ToonPrimitiveKind.NullableBoolean => $"if (item.{name} == null) {{ toonWriter.WriteNull(); }} else {{ toonWriter.WriteBoolean(item.{name}); }}",
                ToonPrimitiveKind.NullableNumber => $"if (item.{name} == null) {{ toonWriter.WriteNull(); }} else {{ toonWriter.WriteNumber(item.{name}); }}",
                ToonPrimitiveKind.NullableString => $"if (item.{name} == null) {{ toonWriter.WriteNull(); }} else {{ toonWriter.WriteString(item.{name}); }}",
                _ => throw new NotSupportedException($"Unsupported property type for Toon serialization: {kind}"),
            };
            return "                "/* indent */ + str;
        }));

        var source = $$"""
// <auto-generated/>
#pragma warning disable
#nullable enable

using Cysharp.AI.Internal;
using System;
using System.Buffers;
using System.IO;
using System.IO.Pipelines;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

namespace Cysharp.AI.Converters
{
    public class {{converterName}} : JsonConverter<{{arrayType}}>
    {
        static readonly ReadOnlyMemory<byte>[] utf8FieldNames = [{{utf8FieldNames}}];

        public static string EncodeAsTabularArray({{arrayType}} value)
        {
            var bufferWriter = new Cysharp.AI.Internal.ValueArrayPoolBufferWriter<byte>();
            try
            {
                EncodeAsTabularArray(ref bufferWriter, value);
                return Encoding.UTF8.GetString(bufferWriter.WrittenSpan);
            }
            finally
            {
                bufferWriter.Dispose();
            }
        }

        public static byte[] EncodeAsTabularArrayToUtf8Bytes({{arrayType}} value)
        {
            var bufferWriter = new ValueArrayPoolBufferWriter<byte>();
            try
            {
                EncodeAsTabularArray(ref bufferWriter, value);
                return bufferWriter.WrittenSpan.ToArray();
            }
            finally
            {
                bufferWriter.Dispose();
            }
        }

        public static async ValueTask EncodeAsTabularArrayAsync(Stream utf8Stream, {{arrayType}} value, CancellationToken cancellationToken = default)
        {
            var writer = PipeWriter.Create(utf8Stream);
            EncodeAsTabularArray(ref writer, value);
            await writer.FlushAsync(cancellationToken);
        }

        public static void EncodeAsTabularArray<TBufferWriter>(ref TBufferWriter bufferWriter, {{arrayType}} value)
            where TBufferWriter : IBufferWriter<byte>
        {
            var toonWriter = ToonWriter.Create(ref bufferWriter);
            EncodeAsTabularArray(ref toonWriter, value);
            toonWriter.Flush();
        }

        public static void EncodeAsTabularArray<TBufferWriter>(ref ToonWriter<TBufferWriter> toonWriter, {{arrayType}} value)
            where TBufferWriter : IBufferWriter<byte>
        {
            if (value == null)
            {
                toonWriter.WriteNull();
                return;
            }

            toonWriter.WriteStartTabularArray(value.Length, utf8FieldNames, escaped: true);

            foreach (var item in value)
            {
                toonWriter.WriteNextRowOfTabularArray();
{{encodeRow}}
            }

            toonWriter.WriteEndTabularArray();
        }

        public override void Write(Utf8JsonWriter utf8JsonWriter, {{arrayType}} value, JsonSerializerOptions options)
        {
            var bufferWriter = new Cysharp.AI.Internal.ValueArrayPoolBufferWriter<byte>();
            try
            {
                EncodeAsTabularArray(ref bufferWriter, value);
                utf8JsonWriter.WriteStringValue(bufferWriter.WrittenSpan);
            }
            finally
            {
                bufferWriter.Dispose();
            }
        }

        public override {{arrayType}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            throw new NotSupportedException("Toon serialization only supports Write.");
        }
    }
}
""";

        sourceProductionContext.AddSource($"{converterName}.g.cs", source.ReplaceLineEndings());
    }

    static void EmitSimpleObjectConverter(SourceProductionContext sourceProductionContext, ToonObjectInfo objectInfo)
    {
        if (!objectInfo.VerifySimpleObject(sourceProductionContext))
        {
            return;
        }

        var converterName = $"{objectInfo.ElementFullName.Replace("global::", "").Replace(".", "_")}SimpleObjectConverter";
        var objectType = $"{objectInfo.ElementFullName}" + (objectInfo.IsReferenceType ? "?" : "");

        List<(string PropName, string Utf8FieldNames)> nestedUtf8FieldNames = new();
        for (int i = 0; i < objectInfo.PropertyKinds!.Length; i++)
        {
            if (objectInfo.PropertyKinds[i] == ToonPrimitiveKind.Array)
            {
                var arrayInfo = objectInfo.NestedArrayInfos![i]!;
                if (arrayInfo.PrimitiveKind == ToonPrimitiveKind.Object)
                {
                    var utf8FieldNames = string.Join(", ", arrayInfo.PropertyNames.Select(n => $"\"{n}\"u8.ToArray()"));
                    nestedUtf8FieldNames.Add((objectInfo.PropertyNames![i], utf8FieldNames));
                }
            }
        }

        var utf8FieldNamesDeclaration = string.Join("\n", nestedUtf8FieldNames.Select(x => $"        static readonly ReadOnlyMemory<byte>[] {x.PropName}_utf8FieldNames = [{x.Utf8FieldNames}];"));

        const string defaultIndent = "            ";
        var encodeRow = new StringBuilder();
        for (int i = 0; i < objectInfo.PropertyNames!.Length; i++)
        {
            var name = objectInfo.PropertyNames[i];
            var kind = objectInfo.PropertyKinds![i];
            var arrayInfo = objectInfo.NestedArrayInfos![i];

            encodeRow.AppendLine(defaultIndent + $"toonWriter.WritePropertyName(\"{name}\");");
            EmitValueLine("value", name, kind, arrayInfo, defaultIndent);

            void EmitValueLine(string instanceName, string propertyName, ToonPrimitiveKind kind, ToonObjectInfo? arrayInfo, string indent)
            {
                var name = propertyName == "" ? instanceName : $"{instanceName}.{propertyName}";
                switch (kind)
                {
                    case ToonPrimitiveKind.Boolean:
                        encodeRow.AppendLine(indent + $"toonWriter.WriteBoolean({name});");
                        break;
                    case ToonPrimitiveKind.Number:
                        encodeRow.AppendLine(indent + $"toonWriter.WriteNumber({name});");
                        break;
                    case ToonPrimitiveKind.String:
                        encodeRow.AppendLine(indent + $"toonWriter.WriteString({name});");
                        break;
                    case ToonPrimitiveKind.NullableNumber:
                        encodeRow.AppendLine(indent + $"if ({name} == null) {{ toonWriter.WriteNull(); }} else {{ toonWriter.WriteNumber({name}); }}");
                        break;
                    case ToonPrimitiveKind.NullableBoolean:
                        encodeRow.AppendLine(indent + $"if ({name} == null) {{ toonWriter.WriteNull(); }} else {{ toonWriter.WriteBoolean({name}); }}");
                        break;
                    case ToonPrimitiveKind.NullableString:
                        encodeRow.AppendLine(indent + $"if ({name} == null) {{ toonWriter.WriteNull(); }} else {{ toonWriter.WriteString({name}); }}");
                        break;
                    case ToonPrimitiveKind.Array:
                        if (arrayInfo!.IsPrimitiveOrArray) // verified, it is not array.
                        {
                            // InlineArray
                            encodeRow.AppendLine(indent + $"if ({name} == null)");
                            encodeRow.AppendLine(indent + "{");
                            encodeRow.AppendLine(indent + "    toonWriter.WriteNull();");
                            encodeRow.AppendLine(indent + "}");
                            encodeRow.AppendLine(indent + "else");
                            encodeRow.AppendLine(indent + "{");
                            encodeRow.AppendLine(indent + $"    toonWriter.WriteStartInlineArray({name}.Length);");
                            encodeRow.AppendLine(indent + $"    foreach (var item in {name})");
                            encodeRow.AppendLine(indent + "    {");
                            EmitValueLine("item", "", arrayInfo.PrimitiveKind, null, indent + "        ");
                            encodeRow.AppendLine(indent + "    }");
                            encodeRow.AppendLine(indent + "    toonWriter.WriteEndInlineArray();");
                            encodeRow.AppendLine(indent + "}");
                        }
                        else
                        {
                            // TabularArray
                            encodeRow.AppendLine(indent + $"if ({name} == null)");
                            encodeRow.AppendLine(indent + "{");
                            encodeRow.AppendLine(indent + "    toonWriter.WriteNull();");
                            encodeRow.AppendLine(indent + "}");
                            encodeRow.AppendLine(indent + "else");
                            encodeRow.AppendLine(indent + "{");
                            encodeRow.AppendLine(indent + $"    toonWriter.WriteStartTabularArray({name}.Length, {propertyName}_utf8FieldNames, escaped: true);");
                            encodeRow.AppendLine(indent + $"    foreach (var item in {name})");
                            encodeRow.AppendLine(indent + "    {");
                            encodeRow.AppendLine(indent + "        toonWriter.WriteNextRowOfTabularArray();");

                            for (var j = 0; j < arrayInfo.PropertyNames!.Length; j++)
                            {
                                var propName = arrayInfo.PropertyNames[j];
                                var propKind = arrayInfo.PropertyKinds![j];
                                var propArrayInfo = arrayInfo.NestedArrayInfos![j];
                                EmitValueLine("item", propName, propKind, propArrayInfo, indent + "        ");
                            }

                            encodeRow.AppendLine(indent + "    }");
                            encodeRow.AppendLine(indent + "    toonWriter.WriteEndTabularArray();");
                            encodeRow.AppendLine(indent + "}");
                        }
                        break;
                    case ToonPrimitiveKind.Object: // already verified, not come here.
                    default:
                        throw new NotSupportedException($"Unsupported property type for Toon serialization: {kind}");
                }
            }
        }

        var emitWriteNull = """
            if (value == null)
            {
                toonWriter.WriteNull();
                return;
            }
""";
        if (!objectInfo.IsReferenceType)
        {
            emitWriteNull = "";
        }

        var source = $$"""
// <auto-generated/>
#pragma warning disable
#nullable enable

using Cysharp.AI.Internal;
using System;
using System.Buffers;
using System.IO;
using System.IO.Pipelines;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

namespace Cysharp.AI.Converters
{
    public class {{converterName}} : JsonConverter<{{objectType}}>
    {
{{utf8FieldNamesDeclaration}}

        public static string Encode({{objectType}} value)
        {
            var bufferWriter = new Cysharp.AI.Internal.ValueArrayPoolBufferWriter<byte>();
            try
            {
                Encode(ref bufferWriter, value);
                return Encoding.UTF8.GetString(bufferWriter.WrittenSpan);
            }
            finally
            {
                bufferWriter.Dispose();
            }
        }

        public static byte[] EncodeToUtf8Bytes({{objectType}} value)
        {
            var bufferWriter = new ValueArrayPoolBufferWriter<byte>();
            try
            {
                Encode(ref bufferWriter, value);
                return bufferWriter.WrittenSpan.ToArray();
            }
            finally
            {
                bufferWriter.Dispose();
            }
        }

        public static async ValueTask EncodeAsync(Stream utf8Stream, {{objectType}} value, CancellationToken cancellationToken = default)
        {
            var writer = PipeWriter.Create(utf8Stream);
            Encode(ref writer, value);
            await writer.FlushAsync(cancellationToken);
        }

        public static void Encode<TBufferWriter>(ref TBufferWriter bufferWriter, {{objectType}} value)
            where TBufferWriter : IBufferWriter<byte>
        {
            var toonWriter = ToonWriter.Create(ref bufferWriter);
            Encode(ref toonWriter, value);
            toonWriter.Flush();
        }

        public static void Encode<TBufferWriter>(ref ToonWriter<TBufferWriter> toonWriter, {{objectType}} value)
            where TBufferWriter : IBufferWriter<byte>
        {
{{emitWriteNull}}

            toonWriter.WriteStartObject();

{{encodeRow}}
            toonWriter.WriteEndObject();
        }

        public override void Write(Utf8JsonWriter utf8JsonWriter, {{objectType}} value, JsonSerializerOptions options)
        {
            var bufferWriter = new Cysharp.AI.Internal.ValueArrayPoolBufferWriter<byte>();
            try
            {
                Encode(ref bufferWriter, value);
                utf8JsonWriter.WriteStringValue(bufferWriter.WrittenSpan);
            }
            finally
            {
                bufferWriter.Dispose();
            }
        }

        public override {{objectType}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            throw new NotSupportedException("Toon serialization only supports Write.");
        }
    }
}
""";

        sourceProductionContext.AddSource($"{converterName}.g.cs", source.ReplaceLineEndings());
    }
}

public record struct LocationSlim(string FilePath, TextSpan TextSpan, LinePositionSpan LinePositionSpan)
{
    public Location CreateLocation()
    {
        if (FilePath == null) return Location.None;
        return Location.Create(FilePath, TextSpan, LinePositionSpan);
    }
}

public record ToonObjectInfo
{
    public string ElementFullName { get; }
    public bool IsReferenceType { get; }
    public LocationSlim Location { get; }
    public ToonPrimitiveKind PrimitiveKind { get; }

    [MemberNotNullWhen(false, nameof(PropertyNames), nameof(PropertyKinds), nameof(NestedArrayInfos))]
    public bool IsPrimitiveOrArray => PrimitiveKind != ToonPrimitiveKind.Object;

    // If not primitive
    public string[]? PropertyNames { get; }
    public ToonPrimitiveKind[]? PropertyKinds { get; }

    // If array
    public ToonObjectInfo?[]? NestedArrayInfos { get; }

    public ToonObjectInfo(ITypeSymbol symbol)
    {
        ElementFullName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        IsReferenceType = symbol.IsReferenceType;

        var location = symbol.Locations.FirstOrDefault();
        if (location != null)
        {
            var lineSpan = location.GetLineSpan();
            Location = new LocationSlim(
                location.SourceTree?.FilePath ?? "",
                location.SourceSpan,
                lineSpan.Span);
        }

        var (kind, _) = GetToonPrimitive(symbol);
        if (kind != ToonPrimitiveKind.Object)
        {
            PrimitiveKind = kind;
            return;
        }
        else
        {
            PrimitiveKind = ToonPrimitiveKind.Object;
        }

        var nameAndKinds = symbol.GetMembers()
            .Where(x => x.DeclaredAccessibility == Accessibility.Public)
            .OfType<IPropertySymbol>()
            .Select(p =>
            {
                var (Kind, NestedInfo) = GetToonPrimitive(p.Type);
                return (p.Name, Kind, NestedInfo);
            })
            .ToArray();

        PropertyNames = nameAndKinds.Select(x => x.Name).ToArray();
        PropertyKinds = nameAndKinds.Select(x => x.Kind).ToArray();
        NestedArrayInfos = nameAndKinds.Select(x => x.NestedInfo!).ToArray();

        static (ToonPrimitiveKind, ToonObjectInfo?) GetToonPrimitive(ITypeSymbol t)
        {
            if (t.NullableAnnotation == NullableAnnotation.Annotated && t is INamedTypeSymbol nts && nts.IsGenericType && nts.Name == "Nullable" && nts.TypeArguments.Length == 1)
            {
                var underlyingType = nts.TypeArguments[0];

                if (underlyingType.TypeKind == TypeKind.Enum || IsGuid(underlyingType) || IsTimeSpan(underlyingType) || IsDateTimeOffset(underlyingType))
                {
                    return (ToonPrimitiveKind.NullableString, null);
                }

                return underlyingType.SpecialType switch
                {
                    SpecialType.System_Boolean => (ToonPrimitiveKind.NullableBoolean, null),
                    SpecialType.System_DateTime => (ToonPrimitiveKind.NullableString, null),
                    SpecialType.System_Byte or
                    SpecialType.System_SByte or
                    SpecialType.System_Int16 or
                    SpecialType.System_UInt16 or
                    SpecialType.System_Int32 or
                    SpecialType.System_UInt32 or
                    SpecialType.System_Int64 or
                    SpecialType.System_UInt64 or
                    SpecialType.System_Single or
                    SpecialType.System_Double or
                    SpecialType.System_Decimal => (ToonPrimitiveKind.NullableNumber, null),
                    _ => (ToonPrimitiveKind.Object, null),
                };
            }
            else
            {
                if (t.TypeKind == TypeKind.Array && t is IArrayTypeSymbol array)
                {
                    var elementType = new ToonObjectInfo(array.ElementType);
                    return (ToonPrimitiveKind.Array, elementType);
                }

                if (t.TypeKind == TypeKind.Enum || IsGuid(t) || IsTimeSpan(t) || IsDateTimeOffset(t))
                {
                    return (ToonPrimitiveKind.String, null);
                }

                return t.SpecialType switch
                {
                    SpecialType.System_Boolean => (ToonPrimitiveKind.Boolean, null),
                    SpecialType.System_DateTime => (ToonPrimitiveKind.String, null),
                    SpecialType.System_String => (ToonPrimitiveKind.String, null),
                    SpecialType.System_Byte or
                    SpecialType.System_SByte or
                    SpecialType.System_Int16 or
                    SpecialType.System_UInt16 or
                    SpecialType.System_Int32 or
                    SpecialType.System_UInt32 or
                    SpecialType.System_Int64 or
                    SpecialType.System_UInt64 or
                    SpecialType.System_Single or
                    SpecialType.System_Double or
                    SpecialType.System_Decimal => (ToonPrimitiveKind.Number, null),
                    _ => (ToonPrimitiveKind.Object, null),
                };
            }

            static bool IsGuid(ITypeSymbol type)
            {
                return type is INamedTypeSymbol { Name: "Guid", ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true } };
            }

            static bool IsTimeSpan(ITypeSymbol type)
            {
                return type is INamedTypeSymbol { Name: "TimeSpan", ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true } };
            }

            static bool IsDateTimeOffset(ITypeSymbol type)
            {
                return type is INamedTypeSymbol { Name: "DateTimeOffset", ContainingNamespace: { Name: "System", ContainingNamespace.IsGlobalNamespace: true } };
            }
        }
    }

    public bool VerifyTabularArray(SourceProductionContext sourceProductionContext)
    {
        var hasUnsupported = false;
        List<string>? unsupportedPropertyNames = null;

        if (IsPrimitiveOrArray)
        {
            hasUnsupported = true;
        }
        else
        {
            for (int i = 0; i < PropertyKinds.Length; i++)
            {
                var kind = PropertyKinds[i];
                if (kind == ToonPrimitiveKind.Object || kind == ToonPrimitiveKind.Array) // only allow primitive
                {
                    if (unsupportedPropertyNames == null)
                    {
                        unsupportedPropertyNames = new List<string>();
                    }
                    unsupportedPropertyNames.Add(PropertyNames[i]);
                    hasUnsupported = true;
                }
            }
        }

        if (hasUnsupported)
        {
            sourceProductionContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                "TEG001",
                "Unsupported Property Type for Toon Tabular Array Converter",
                $"The property type is not supported for Toon Tabular Array serialization in {ElementFullName.Replace("global::", "")}.{string.Join(", ", unsupportedPropertyNames ?? [])}.",
                "ToonEncoderGenerator",
                DiagnosticSeverity.Error,
                isEnabledByDefault: true), Location.CreateLocation()));

            return false;
        }

        return true;
    }

    public bool VerifySimpleObject(SourceProductionContext sourceProductionContext)
    {
        var hasUnsupported = false;
        List<string>? unsupportedPropertyNames = null;

        if (IsPrimitiveOrArray)
        {
            hasUnsupported = true;
        }
        else
        {
            for (int i = 0; i < PropertyKinds.Length; i++)
            {
                void AddUnsupported()
                {
                    if (unsupportedPropertyNames == null)
                    {
                        unsupportedPropertyNames = new List<string>();
                    }
                    unsupportedPropertyNames.Add(PropertyNames![i]);
                    hasUnsupported = true;
                }

                var kind = PropertyKinds[i];
                if (kind == ToonPrimitiveKind.Object)
                {
                    AddUnsupported();
                }
                else if (kind == ToonPrimitiveKind.Array)
                {
                    // when array, need to verify inner as primitive(InlineArray) or primitive object(TabularArray).
                    var arrayInfo = NestedArrayInfos[i]!;

                    if (arrayInfo.PrimitiveKind == ToonPrimitiveKind.Array) // array of array is NG.
                    {
                        AddUnsupported();
                    }
                    else if (arrayInfo.PrimitiveKind == ToonPrimitiveKind.Object)
                    {
                        // check is TabularArray
                        for (int j = 0; j < arrayInfo.PropertyKinds!.Length; j++)
                        {
                            var pk = arrayInfo.PropertyKinds[j];
                            if (pk == ToonPrimitiveKind.Object || pk == ToonPrimitiveKind.Array)
                            {
                                AddUnsupported();
                                break;
                            }
                        }
                    }
                }
            }
        }

        if (hasUnsupported)
        {
            sourceProductionContext.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                "TEG002",
                "Unsupported Property Type for Toon Simple Object Converter",
                $"The property type is not supported for Toon Simple Object serialization in {ElementFullName.Replace("global::", "")}.{string.Join(", ", unsupportedPropertyNames)}. Property must be toon-primitive or primitive-array or tabular-array convertible array.",
                "ToonEncoderGenerator",
                DiagnosticSeverity.Error,
                isEnabledByDefault: true), Location.CreateLocation()));

            return false;
        }

        return true;
    }
}

public enum ToonPrimitiveKind
{
    Boolean,
    Number,
    String,
    NullableNumber,
    NullableBoolean,
    NullableString,

    Array,

    Object // Object or Unsupported Primitive
}
